const v1 = Symbol.iterator;
const v10 = {
    [v1]() {
        let v3 = 10;
        const v9 = {
            next() {
                v3--;
                const v7 = v3 == 0;
                return { done: v7, value: v3 };
            },
        };
        return v9;
    },
};
const v13 = new BigUint64Array(0);
try { v13.entries(); } catch (e) {}
function f15() {
    return BigUint64Array;
}
-15 >>> -15;
-174;
Uint16Array.e = Uint16Array;
new Uint16Array(174);
[483957487,65537,9007199254740990,12,2,-9007199254740990];
new Uint16Array(64);
const v28 = ([10000,-599807635,-1000325389,-1429111283,1000])?.constructor;
try { new v28("boolean"); } catch (e) {}
function f30() {
}
class C33 extends f30 {
}
try { Object.values(v10); } catch (e) {}
const v36 = new C33();
const v38 = {};
for (let i = 0; i < 10; i++) {
    try { Reflect.isExtensible(Symbol); } catch (e) {}
    [];
    4066 - 4066;
    Int8Array.e = Int8Array;
    function F46(a48, a49) {
        if (!new.target) { throw 'must be called with new'; }
    }
}
Intl.DateTimeFormat;
undefined ?? undefined;
34 | 34;
class C57 {
}
try { Symbol.for(Symbol); } catch (e) {}
new Uint16Array();
class C64 extends Float64Array {
}
C64.b = C64;
function f66(a67) {
    function f69(a70) {
        Uint8Array.fromHex("bF8ca37EedE1cDE9CB16baC40bf9");
    }
    class C74 extends f69 {
    }
    new C74();
}
async function* f78(a79, a80) {
}
try { new f78(34, v36); } catch (e) {}
f78().return();
new Worker(f66, { type: "function" });
new C64();
